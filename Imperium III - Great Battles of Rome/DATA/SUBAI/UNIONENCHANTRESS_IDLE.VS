// void, Obj This

Druid this;
Unit tgt;
point ptStart;
Building bldEnter;
int level, level1, level2;
int i;
bool bSuccess;
int action;
int learntimes;
int teach_stamina_cost, learn_stamina_cost, heal_stamina_cost;
bool bCanTeach, bCanLearn, bCanHeal;
int chance, k;
Obj hInvalid;

this = This.AsDruid();
if (!.IsValid) return;
while (!.Stop(1000));

action = 2;
ptStart = .posRH;
if (!.InShip && .InHolder) 
	bldEnter = .GetHolderSett.GetCentralBuilding;

teach_stamina_cost = GetCmdStaminaCost("teach");
learn_stamina_cost = GetCmdStaminaCost("learn");
heal_stamina_cost = GetCmdStaminaCost("heal");

chance = GetConst("EnchantressTeachPercent");
if (IsResearched(.player, "Code of Valor"))
	chance += .level * GetConst("EnchantressTeachIncrease");
k = chance / 100;
chance = chance % 100;

bCanTeach = .HasSpecial(teaching);
bCanLearn = true;

bCanHeal = .HasSpecial(healing);

//TO WHAT LEVEL SHOULD WE TRAIN UNITS?
level1 = GetConst("TeachingLevel1");
level2 = GetConst("TeachingLevel2");

level = level1;
if (EnvReadString(.player, "Ancestral Knowledge") == "researched")
	level = level2;
tgt = .FindUnitBelowILevel(level).AsUnit;

while (true)
{
	if (tgt.IsDead) tgt = hInvalid; /// avoid handle reuse problems
	
	//SLEEP 2000 IF INACTIVE
	if (.hero.IsValid) if (.hero.command=="teleport")
	{
		Sleep(2000);
		continue;
	}
	if (!.AI) if(.InHolder)
	{
		Sleep(2000);
		continue;
	}
	if (!.AI) if(!.IsVisible) if (.IsEnemyInSquadSight)
	{	// do not teach/learn if enemies and hiden
		Sleep(2000);
		continue;
	}

	//TO WHAT LEVEL SHOULD WE TRAIN UNITS?
	if (level < level2) if (EnvReadString(.player, "Ancestral Knowledge") == "researched")
		level = level2;

	bSuccess = false;
	if (.hero.IsValid) if (!.hero.InHolder)
	{//GO NEAR HERO IF TOO FAR
		if (.DistTo(.hero) > 250)
		{
			.Goto(.hero, 250, 2000, false, -1);
			ptStart = .pos;
			continue;
		}
	}
	else
	{//GO NEAR STARTPOINT IF TOO FAR
		if (.DistTo(ptStart) > .sight)
		{
			.Goto(ptStart, .sight, 2000, false, -1);
			continue;
		}
	}

	//AI COMBAT MAGIC
	if (.AI)
	{
		if (.health >= .maxhealth / 2) if (AIVar(.player, AIV_CombatMagic) != 0)
		{
			if (!.InHolder) if (IsResearched(.player, "Cover of Mercy"))
			{
				Sleep(rand(50) + 30);
				if ((.health >= .maxhealth / 2))
				{
					Obj o;
					o = .BestProtPos(80, 0, 1000, 50);
					if (o.AsUnit.IsValid) if (!IsProtected(.player, o.posRH, "CoverOfMercy")) {
						.AddCommand(true, "coverofmercy", o.posRH);
						return;
					}
				}
			}
		}
	}

	//TEACH/LEARN
	learntimes = 0;
	while (learntimes < 10)
	{
		//BAD POTENTIALITIES
		if (action == 2) if (!bCanTeach) break;
		if (action == 3) if (!bCanLearn) break;

		//BAD TARGETS
		if (!tgt.IsAlive)  break;
		if (.IsEnemy(tgt)) break;
		if (tgt.InHolder)  break;
		if (!.CanSee(tgt)) break;
		if (tgt == this)   break;
		if (!.IsVisible)   break;
		if (tgt.DistTo(ptStart) > .range + .sight) break;

		//EARLY BREAK IF TEACH CAN NOT BE DONE, AND TEACH IS THE CURRENT ACTION
		if (action == 2) {
			if (tgt.inherentlevel >= level) {// if teach is done then heal
				//EARLY BREAK IF HEALING CAN NOT BE DONE, AND HEAL IS THE CURRENT ACTION
				if (tgt.health >= tgt.maxhealth) break;
				if (.stamina < heal_stamina_cost) break;
				//GOING NEAR TARGET
				if (!.InRange(tgt) || .InHolder)
				{
					if (!.hero.IsValid) if (.DistTo(ptStart) > .sight)
						break;
					.GotoAttack(tgt, 2000, false, 2500);
					continue;
				}
				
				{	//HEAL
					.StartAnim(17, tgt.pos);
					Sleep(.TimeToActionMoment());
					
					if (tgt.IsAlive)
					if (tgt.health < tgt.maxhealth)
					if (!tgt.InHolder)
					if (.CanSee(tgt))
					if (.stamina >= heal_stamina_cost)
					{
						.SetVisible(true); .SetLastAttackTime();
						.SetStamina(.stamina - heal_stamina_cost);
						amount = GetConst("HealAmount") + .level;
						tgt.Heal(amount);
						CreateFeedback("Heal", tgt);
					}
					Sleep(.TimeToAnimFinish());
					bSuccess = true;
					continue;
				}
			}
			if (.stamina < teach_stamina_cost) break;
		}

		//EARLY BREAK IF LEARNING CAN NOT BE DONE AND LEARN IS THE CURRENT ACTION
		if (action == 3) {
			if (tgt.experience <= .experience) break;
			if (.stamina < learn_stamina_cost) break;
		}

		//GOING NEAR TARGET
		if (!.InRange(tgt) || .InHolder) 
		{
			if (!.hero.IsValid) if(.DistTo(ptStart) > .sight)
				break;
			.GotoAttack(tgt, 2000, false, 2500);
			continue;
		}

		if (action == 2)
		{	//TEACHING
			.StartAnim(17, tgt.pos);
			Sleep(.TimeToActionMoment());
			
			if (tgt.IsAlive)
			if (tgt.inherentlevel < level)
			if (.stamina >= teach_stamina_cost)
			if (!tgt.InHolder)
			if (.CanSee(tgt))
			if (!.IsEnemy(tgt))
			{
				.SetVisible(true); .SetLastAttackTime();
				.SetStamina(.stamina - teach_stamina_cost);
				tgt.SetExperience(tgt.experience + k + (chance > rand(99)));
				CreateFeedback("Experience", tgt);
			}
			Sleep(.TimeToAnimFinish());
			bSuccess = true;
			continue;
		}
		if (action == 3)
		{	//LEARN
			.StartAnim(19, tgt.pos);
			Sleep(.TimeToActionMoment());
		
			if (tgt.IsAlive)
			if (tgt.experience > .experience)
			if (!tgt.InHolder)
			if (.CanSee(tgt))
			if (.stamina >= learn_stamina_cost)
			if (!.IsEnemy(tgt))
			{
				int exp; exp = .experience + (.inherentlevel + 3) / 4;
				if (exp > tgt.experience) exp = tgt.experience;
				.SetVisible(true); .SetLastAttackTime();
				.SetStamina(.stamina - learn_stamina_cost);
				.SetExperience(exp);
				CreateFeedback("Experience", this);
			}
			Sleep(.TimeToAnimFinish());
			learntimes += 1;
			bSuccess = true;
			continue;
		}
		Sleep(1000);//just in case something went wrong
	}

	if (.InHolder) {
		Sleep(2113);
		continue;
	}

	if (.hero.IsValid)
	{
		if (.DistTo(.hero.dest)>250)
		{
			if (.Goto(.hero.dest, 200, 2000, false, -1))
				.Idle(1000);
		}
		else
			.Idle(1000);
	}
	else
	{
		.Idle(1000);
	}
			
	while (1)
	{
		if (.IsEnemyInSquadSight && bCanTeach)
			action = 2;//TEACH
		else if (!bSuccess || action == 3) {
			action = 5 - action;//2, 3, 2, 3, .....
		}
		for (i = 0; i < 2; i += 1) {
			if (action == 2 && !bCanTeach) action = 5;
			if (action == 5 && !bCanLearn) action = 2;
			if (action == 2)
				tgt = .FindUnitBelowILevel(level).AsUnit;
			else
				tgt = .FindUnitToLearn.AsUnit;
			if (tgt.IsValid) break;
			if (!bCanTeach || !bCanLearn) break;
			action = 5 - action;
		}

		if(tgt.IsAlive()) if(tgt.DistTo(ptStart) - .range < .sight)
		{
			.GotoAttack(tgt, 2000, false, 2500);
			break;
		}
		
		if (.hero.IsValid)
			break;
		if (bldEnter.IsValid) {
			if (!.IsEnemy(bldEnter)) {
				point pt; pt = bldEnter.GetEnterPoint(this);
				if (!.GotoEnter(pt, 0, 1000, true, 5000))
					continue;
				.AddCommand(true, "enter", bldEnter);
				return;
			} else {
				bldEnter.Clear;
				ptStart = .posRH;
			}
		}

		if (.AI)
		if (!.hero.IsValid)
		if (!.InHolder)
		if (IsWaterLsa(ptStart.GetGAIKA.LSA))
		{	/// leave the coast
			point pt;
			pt.Set(.pos.x + (128 - rand(256)), .pos.y + (128 - rand(256)));
			if (pt.InRect(GetMapRect))
			if (IsPassable3x3(pt))
			if (!IsWaterLsa(pt.GetGAIKA.LSA))
				ptStart = pt;
		}

		if(.Goto(ptStart, 0, 2000, true, 1000))
		{
			.Idle(2000);
			break;
		}
	}
}
